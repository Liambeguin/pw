#!/usr/bin/python3
# vim: fileencoding=utf-8 cc=80 et tw=79 ts=4

import os
import sys
import time
import argparse
import logging

import requests
from bs4 import BeautifulSoup


class PowerSwitch:
    def __init__(self, conffile, loglevel):
        '''Initialize the PowerSwitch instance by setting it's configuration
        file, url, timeouts and outlets'''

        logging.basicConfig(format='%(levelname)s: %(message)s')
        self.logger = logging.getLogger(__name__)
        self.logger.setLevel(loglevel)

        # self.configuration contains all what is defined in the config file
        self.conffile = self.config_get_or_create(conffile)
        self.configuration = self.config_parse()

        self.url = 'http://' + str(self.configuration['POWER_SWITCH_IP'])
        self.logger.debug(f'power switch url is {self.url}')

        self.timeout = (0.25, 1)
        self.logger.debug(f'power switch timouts are {self.timeout}')

        self.delay = []

        self._request_count = 0
        self._max_request_count = 5

        self.name = self.get_switch_name()
        self.outlets = self.get_outlets_state()

    def _get_pw(self, page, payload):
        '''Send a request to the PowerSwitch'''

        self.logger.debug('try : {self._request_count + 1}')

        try:
            ret = requests.get(page, timeout=self.timeout, params=payload,
                               auth=(self.configuration['USER'],
                                     self.configuration['PASSWORD']))
        except (requests.exceptions.ReadTimeout,
                requests.exceptions.ConnectTimeout,
                requests.exceptions.ConnectionError):
            if (self._request_count <= self._max_request_count):
                self._request_count += 1
                ret = self._get_pw(page, payload)
            else:
                self._request_count = 0
                raise Exception(' ERROR: Connection failed')

        self._request_count = 0
        return ret

    def config_get_or_create(self, conffile):
        # NOTE: expected_path is a list of paths where pw should look to find a
        #       configuration file.
        #       The first element has priority and overrides the others.
        #       If none of them exists, a file will be created in
        #       expected_path[0]. That path must be writable by the user!

        expected_path = ['~/.', '/etc/pw/']
        expected_path = [path + conffile for path in expected_path]
        expected_path = [os.path.expanduser(path) for path in expected_path]

        config = expected_path[0]

        for path in expected_path:
            if os.path.exists(path):
                config = path
                break

        self.logger.debug('configuration file is %s', config)
        if not os.path.exists(config):
            print('Generating configuration file...')
            ip = raw_input('IP address [192.168.0.100] : ') or '192.168.0.100'
            user = raw_input('username [admin] : ') or 'admin'
            passwd = raw_input('password [] : ') or''

            f = open(config, 'w')
            f.write('# more information on at: github.com/liambeguin/pw\n')
            f.write('USER=\"' + user + '\"\n')
            f.write('PASSWORD=\"' + passwd + '\"\n')
            f.write('POWER_SWITCH_IP=\"' + ip + '\"\n')
            f.close()
            os.chmod(config, 600)

        return config

    def config_parse(self):
        '''Parse the configuration file'''

        options = {}
        f = open(self.conffile)
        for line in f:
            # First, remove comments:
            if '#' in line:
                # split on comment char, keep only the part before
                line, comment = line.split('#', 1)
                # Second, find lines with an option=value:
            if '=' in line:
                # split on option char:
                option, value = line.split('=', 1)
                # strip spaces quotes and newline
                option = option.strip()
                value = value.strip(" \"\n")
                # store in dictionary:
                options[option] = value
        f.close()
        return options

    def get_switch_revision(self):
        '''Returns a dictionary of 3 revision numbers'''

        r = self._get_pw(self.url + '/support.htm', None)

        soup = BeautifulSoup(r.text, 'html.parser')

        ret = {}
        # FIXME: This is based on the assumption that the different
        # fields do not change order in other revisions..
        table_lines = soup.findAll('td', width='70%')
        ret['firmware'] = table_lines[0].string.strip()
        ret['hardware'] = table_lines[1].string.strip()
        ret['serialnum'] = table_lines[3].string.strip()

        return ret

    def resolve_outlet(self, identifier):
        for o in self.outlets:
            if o['name'] == identifier or o['index'] == identifier:
                return o['index']

    def get_switch_name(self):
        '''Returns the PowerSwitch name'''

        r = self._get_pw(self.url + '/index.htm', None)
        soup = BeautifulSoup(r.text, 'html.parser')

        return soup.findAll('th', bgcolor='#DDDDFF')[0].string.strip()

    def get_outlets_state(self):
        '''Returns a list of dictionaries containing each outlet's state'''

        r = self._get_pw(self.url + '/index.htm', None)
        soup = BeautifulSoup(r.text, 'html.parser')

        ret = []
        for table_line in soup.findAll('tr', bgcolor='#F4F4F4'):
            outlet = {}
            index = int(table_line.findAll('td')[0].string)
            # Add other outlet specifics here
            outlet['index'] = str(index)
            outlet['name'] = str(table_line.findAll('td')[1].string)
            outlet['state'] = str(table_line.findAll('font')[0].string)
            ret.append(outlet)

        return ret

    def _check_outlet(self, outlet):
        if str(outlet) not in 'all 1 2 3 4 5 6 7 8':
            print(' ERROR: Asking for an outlet out of range !')
            sys.exit(1)

    def print_outlet_state(self, outlet=None):
        '''Prints outlet states'''

        self.get_outlets_state()
        print(self.name)
        if outlet is None:
            for outlet in self.outlets:
                name = outlet['name']
                idx = outlet['index']
                state = outlet['state']
                print(f'  {name:.<25} {idx} - {state}')
        else:
            self._check_outlet(outlet)
            outlet = self.outlets[int(outlet) - 1]
            name = outlet['name']
            idx = outlet['index']
            state = outlet['state']
            print(f'  {name:.<25} {idx} - {state}')

    def set_outlet_state(self, outlet, state):
        '''Set a specific outlet to a given state (ON, OFF, CCL)'''

        self._check_outlet(outlet)
        if state in 'on off ccl':
            payload = {outlet: state.upper()}
        else:
            raise Exception('%s is not a valid state.' % state)

        self._get_pw(self.url + '/outlet', payload)

    def toggle_outlet(self, outlet):
        '''Toggle a specific outlet's state'''

        self._check_outlet(outlet)
        if self.outlets[int(outlet)-1]['state'] == 'OFF':
            self.set_outlet_state(outlet, 'on')
        else:
            self.set_outlet_state(outlet, 'off')

    def set_name(self, outlet, name):
        '''Sets the controller or a given outlet's name'''

        if outlet == 'ctrl':
            payload = {'ctrlname': name}
        else:
            self._check_outlet(outlet)
            for out in self.outlets:
                if name == out['name']:
                    raise Exception('This name is already used by '
                                               'outlet ' + out['index'])

            payload = {'outname'+str(outlet): name}

        self._get_pw(self.url + '/unitnames.cgi?data', payload)

    def reset_outlet_name(self, outlet=None):
        '''Sets a given outlet's name to 'Outlet i' where i is it's index'''

        if outlet is None:
            for i in self.outlets:
                self.set_name(i['index'], 'Outlet '+str(i['index']))
        else:
                self.set_name(outlet, 'Outlet '+str(outlet))

    def get_delay_settings(self):
        '''Returns a dictionary of delay settings.
        check "delay" section on your switch's
        admin page for more information.'''

        r = self._get_pw(self.url + '/admin.htm', None)
        soup = BeautifulSoup(r.text, 'html.parser')

        for i in range(9, 13):
            tmp = soup.findAll('tr', bgcolor='#F4F4F4')[i]
            delay = {}
            delay[tmp.findAll('td')[0].string.replace(' ', '_')] = \
                tmp.findAll('td')[1].find('input').get('value')
            self.delay.append(delay)


def parse_cmdline():
    parser = argparse.ArgumentParser(description='Control a DLI PowerSwitch over commandline')
    parser.add_argument('--conffile', default=f'{os.path.basename(__file__)}.conf',
                        help='path to a PowerSwitch configuration file')
    parser.add_argument('--log', default='info', help='Change default log level',
                        choices='debug info warning error critical'.split())

    subpar = parser.add_subparsers(help='Sub-Commands', dest='action')
    parser_set = subpar.add_parser('set', help='Set the outlet to a given state')
    parser_get = subpar.add_parser('get', help='Get the name and state of the outlets')
    parser_tgl = subpar.add_parser('tgl', help='Toggle the state of an outlet')
    parser_ccl = subpar.add_parser('ccl', help='Power cycle a given outlet')
    parser_reset = subpar.add_parser('reset', help='Rename an outlet to a default value')
    parser_rename = subpar.add_parser('rename', help='Rename a given outlet. '
                                      'If outlet is \'ctrl\' this will rename the switch')
    parser_version = subpar.add_parser('version', help='Display version information')

    parser_set.add_argument('outlet',
                            help='number or name of the outlet to be controlled')
    parser_set.add_argument('state', choices='on off ccl'.split(),
                            help='Desired state of the outlet')

    parser_get.add_argument('outlet', nargs='?',
                            help='number or name of the outlet to be controlled')

    parser_tgl.add_argument('outlet',
                            help='number or name of the outlet to be controlled')

    parser_ccl.add_argument('--delay', default=None,
                            help='Set number of seconds when power cycling')
    parser_ccl.add_argument('outlet',
                            help='number or name of the outlet to be controlled')

    parser_reset.add_argument('outlet',
                            help='number or name of the outlet to be controlled')

    parser_rename.add_argument('outlet',
                            help='number or name of the outlet to be controlled')
    parser_rename.add_argument('name',
                            help='new outlet name')

    return parser.parse_args()

def version():
    '''Extract revision from Git history'''
    import subprocess

    describe = 'git describe --abbrev=8 --always --dirty'.split()

    try:
        version = subprocess.check_output(describe, stderr=subprocess.STDOUT)
    except subprocess.CalledProcessError:
        version = '%%VERSION%%'

    return f'{version.strip()}'


if __name__ == '__main__':
    options = parse_cmdline()

    pw = PowerSwitch(options.conffile, options.log.upper())

    if options.outlet:
        options.outlet = pw.resolve_outlet(options.outlet)

    if options.action == 'set':
        pw.set_outlet_state(options.outlet, options.state)
    elif options.action == 'get':
        pw.print_outlet_state(options.outlet)
    elif options.action == 'tgl':
        pw.toggle_outlet(options.outlet)
    elif options.action == 'ccl':
        pw.set_outlet_state(options.outlet, 'ccl')
    elif options.action == 'rename':
        pw.set_name(options.outlet, options.name)
    elif options.action == 'reset':
        pw.reset_outlet_name(options.outlet)
    elif options.action == 'version':
        rev = pw.get_switch_revision()
        print(f'{filename} version {version()}\n')
        for k, v in rev.items():
            print('{k:10}\t{v}')


